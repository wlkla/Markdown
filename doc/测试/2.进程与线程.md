# 进程与线程

进程的组成（3）[^1]、进程的特点（4）[^2]、进程存在[^3]、PCB包含的内容（4）[^4]、PCB组织方式（2）[^5]、进程的状态（5）[^6]、引起进程终止的事件（3）[^7]、进程创建原语[^8]、进程终止原语[^9]、进程阻塞原语[^10]、进程唤醒原语[^11]、进程切换原语[^12]、高级通信（3）[^13]、引入进程/线程的目的[^14]、线程的组成[^15]、线程与进程的比较（6）[^16]、线程的状态（3）[^17]、线程的分类（2）[^18]、多线程模型（3）[^19]、调度的分类（3）[^20]、调度器的组成（3）[^21]、不能调度和切换的情况（2）[^22]、调度的目标（5）[^23]、调度算法（7）[^24]、访问临界资源的过程（4）[^25]、同步机制遵循准则（4）[^26]、互斥实现方法（2）[^27]、信号量的操作（3）[^28]、信号量的分类（2）[^29]、经典同步问题（）[^30]、管程的组成（4）[^31]、条件变量[^32]、死锁的必要条件（4）[^33]、死锁的处理（3）[^34]、死锁预防[^35]、死锁解除（3）[^36]

[^1]:进程控制块PCB、数据段、程序段
[^2]:动态性、并发性、独立性、异步性
[^3]:进程存在的唯一标志：PCB
[^4]:进程描述信息（PID、UID）、进程控制和管理信息（进程当前状态、进程优先级、代码运行入口地址、程序的外存地址、进入内存时间、CPU占用时间、信号量使用）、资源分配清单（代码段指针、数据段指针、堆栈段指针、文件描述符、键盘、鼠标）、处理机相关信息（通用寄存器值、地址寄存器值、控制寄存器值、状态字）
[^5]:链接方式、索引方式
[^6]:创建态、运行态、阻塞态、就绪态、终止态
[^7]:正常结束、异常终止、外界干预
[^8]:分配PID->申请空白PCB(没有则失败)->分配资源(不足则等待)->初始化PCB->插入就绪队列
[^9]:根据PID检索PCB->读出进程状态->运行则终止->通常终止其所有子进程->资源归还->删除PCB
[^10]:根据PID检索PCB->状态转换并保护现场->更换队列->资源调度
[^11]:检索PCB->从等待队列移出->更改状态为就绪态->插入就绪队列
[^12]:将运行环境信息存入PCB->PCB移入相应队列->选择另一个进程执行->更新PCB->恢复现场
[^13]:共享存储（低级：基于数据结构；高级：基于存储区）、消息传递（直接通信方式、间接通信方式）、管道通信
[^14]:进程：更好地使躲到程序并发执行，提高资源利用率和系统吞吐量；线程：减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能
[^15]:线程ID、程序计数器、寄存器集合、堆栈等
[^16]:调度（拥有资源：进程，调度：线程）、并发性（不同进程，同一/不同进程的不同线程）、拥有资源（进程拥有资源，线程共享进程资源）、独立性（进程拥有独立的地址空间和资源，线程共享进程空间和资源）、系统开销（进程切换开销大，线程切换开销小）、支持多处理器系统
[^17]:阻塞态、就绪态、运行态
[^18]:用户级线程ULT、内核级线程KLT
[^19]:多对一模型、一对一模型、多对多模型
[^20]:高级调度、中级调度、低级调度
[^21]:排队器、分配器、上下文切换器
[^22]:在处理中断时、需要屏蔽中断的原子操作
[^23]:CPU利用率、系统吞吐量、周转时间、等待时间、响应时间
[^24]:先来先服务调度算法、短作业优先调度算法、时间片轮转调度算法、高响应比优先调度算法、优先级调度算法、多级队列调度算法、多级反馈队列调度算法
[^25]:进入区、临界区、退出区、剩余区
[^26]:空闲则进、忙则等待、有限等待、让权等待
[^27]:软件方法（单标志法、双标志先检查法、双标志后检查法、Peterson算法）、硬件方法（中断屏蔽、TestAndSet指令、Swap指令）
[^28]:init、wait、signal
[^29]:整型信号量、记录型信号量
[^30]:生产者-消费者问题、读者-写者问题、哲学家进餐问题、吸烟者问题
[^31]:名称、局限于管程内部的共享数据结构说明、对数据结构的操作、对共享数据初始化的语句
[^32]:无值、阻塞原因、对应一个阻塞队列
[^33]:互斥条件、不可剥夺条件、请求并保持条件、循环等待条件
[^34]:死锁预防、死锁谜面、死锁的检测与解除
[^35]:请求并保持（一次申请全部、释放后才可申请）、循环等待（顺序资源分配）
[^36]:资源剥夺法、撤销进程法、进程回退法

