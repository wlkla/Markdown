# 数据的表示与运算

进制间的转换(2)[^1]、真值与机器数[^2]、原补反移(4)[^3]、运算器的组成(4+)[^4]、标志位(4)[^5]、逻辑移位[^6]、算术移位(2)[^7]、补码的加减法(2)[^8]、$[B]_补$与$[-B]_补$的转换[^9]、补码加减法判断溢出(3)[^10]、整数大小的比较(2)[^11]、定点数补码的乘法[^12]、乘法溢出判断[^13]、定点数的除法(2)[^14]、浮点数的格式[^15]、IEEE 754标准[^16]、IEEE 754特殊表示(4)[^17]、浮点数的加减运算(4)[^18]、数据存储方式(2)[^19]、数据边界对齐

[^1]:除基取余法、乘基取整法
[^2]:符号的区别

[^3]:(0、1……、127、0、-1、……、-127)、(0、1、……、127、-127、-126、……、-1、0)、(0、1、……、127、-128、-127、……、-1)、(-128、-127、……、0、1、2、……、126、127)
[^4]:ALU、移位器、状态寄存器、通用寄存器组等
[^5]:OF(仅限于有符号整数，=$C_n\oplus C_{n-1}$)、SF(仅限于有符号整数，结果的符号)、ZF(零标志)、CF(仅限于无符号整数，=$C_{out}\oplus C_{in}$)
[^6]:左移：低位补0；右移：高位补0
[^7]:左移：低位补0，右移：高位补符号位
[^8]:$[A+B]_补=[A]_补+[B]_补 \ (mod \ 2^{n+1}) \ \ \ [A-B]_补=[A]_补+[-B]_补 \ (mod \ 2^{n+1}) $
[^9]:找到最后一个1，前面数字全部取反
[^10]:采用一位符号位、采用双符号位(4)、采用一位符号位根据数值位的进位情况判断($V=C_n\oplus C_{n-1}$)
[^11]:无符号整数(ZF=1：相等；ZF=0&CF=0：大于)、有符号整数(ZF=1：相等；ZF=0&$OF\oplus SF=0$：大于)
[^12]:op=辅助位-最后一位；$[opX]_补$，最后一次只加不移位
[^13]:无符号整数：高32位全0；有符号整数：高32位相等且等于低32位符号
[^14]:原码：恢复余数法、加减交替法；补码：同号减商1，异号加商0，末位恒置1
[^15]:符号、阶码、尾数(尾数用原码表示)
[^16]:float：1+8+23($(-1)^s\times 1.f\times 2^{e-127}$)；double：1+11+52($(-1)^s\times 1.f\times 2^{e-1023}$)
[^17]:(0+0)、(1+0)、(1+!0)、(0+!0)
[^18]:对阶、尾数加减、尾数规格化、舍入(就近舍入、正向舍入、负向舍入、截断法)
[^19]:大端对齐、小端对齐、MSB、LSB





